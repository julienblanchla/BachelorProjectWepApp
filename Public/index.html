<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nordic Thingy Dashboard - Professional Sensor Monitoring</title>
  <link rel="stylesheet" href="/style/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <style>
    /* Am√©liorations CSS pour la section Live Sensor Data */
    .data-list {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 1.5rem;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      overflow: hidden;
      position: relative;
    }

    .data-list h2 {
      margin: 0 0 1.2rem 0;
      font-size: 1.3rem;
      font-weight: 600;
      color: #1e293b;
      text-align: center;
      letter-spacing: -0.025em;
    }

    /* Grille optimis√©e pour les cartes de capteurs */
    .sensor-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 1rem;
      height: 100%;
      max-height: 320px;
      overflow: hidden;
    }

    /* Styles am√©lior√©s pour les cartes de capteurs */
    .sensor-card {
      background: linear-gradient(135deg, #f8fafc, #f1f5f9);
      border-radius: 16px;
      padding: 1rem;
      border-left: 4px solid #3b82f6;
      box-shadow: 0 4px 16px rgba(0,0,0,0.08);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      min-height: 0;
      max-height: 150px;
      overflow: hidden;
      word-wrap: break-word;
      word-break: break-word;
      position: relative;
      border: 1px solid rgba(203, 213, 225, 0.3);
    }

    .sensor-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    }

    /* Couleurs sp√©cifiques par type de capteur */
    .sensor-card.accelerometer { 
      border-left-color: #10b981;
      background: linear-gradient(135deg, #f0fdf4, #dcfce7);
    }
    
    .sensor-card.temperature { 
      border-left-color: #f59e0b;
      background: linear-gradient(135deg, #fffbeb, #fef3c7);
    }
    
    .sensor-card.humidity { 
      border-left-color: #06b6d4;
      background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
    }
    
    .sensor-card.air-quality { 
      border-left-color: #8b5cf6;
      background: linear-gradient(135deg, #faf5ff, #f3e8ff);
    }

    /* Titre des cartes */
    .sensor-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: #1e293b;
      margin: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-shrink: 0;
      text-align: center;
      padding-bottom: 0.3rem;
      border-bottom: 2px solid rgba(203, 213, 225, 0.2);
    }

    /* Valeurs des capteurs */
    .sensor-value {
      font-size: 0.8rem;
      color: #374151;
      margin: 0.1rem 0;
      font-weight: 500;
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1.3;
      flex-shrink: 0;
      text-align: center;
      background: rgba(255, 255, 255, 0.5);
      padding: 0.3rem 0.5rem;
      border-radius: 6px;
      border: 1px solid rgba(203, 213, 225, 0.2);
    }

    /* Styles sp√©ciaux pour l'acc√©l√©rom√®tre */
    .sensor-card.accelerometer .sensor-value {
      font-size: 0.75rem;
      margin: 0.05rem 0;
      padding: 0.25rem 0.4rem;
    }

    /* Messages d'alerte */
    .alert-message {
      font-size: 0.7rem;
      padding: 0.4rem 0.5rem;
      border-radius: 8px;
      margin-top: auto;
      font-weight: 500;
      text-align: center;
      word-wrap: break-word;
      word-break: break-word;
      hyphens: auto;
      line-height: 1.2;
      max-height: 40px;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      flex-shrink: 0;
    }

    .alert-message.good { 
      background: #dcfce7; 
      color: #166534; 
      border: 1px solid #bbf7d0;
      box-shadow: 0 2px 4px rgba(16, 185, 129, 0.1);
    }

    .alert-message.warning { 
      background: #fef3c7; 
      color: #92400e; 
      border: 1px solid #fde68a;
      box-shadow: 0 2px 4px rgba(245, 158, 11, 0.1);
    }

    .alert-message.danger { 
      background: #fee2e2; 
      color: #dc2626; 
      border: 1px solid #fecaca;
      box-shadow: 0 2px 4px rgba(239, 68, 68, 0.1);
    }

    .alert-message:empty {
      display: none;
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      .sensor-grid {
        gap: 0.8rem;
        max-height: 300px;
      }
      
      .sensor-card {
        padding: 0.8rem;
        max-height: 140px;
      }
      
      .sensor-title {
        font-size: 0.85rem;
      }
      
      .sensor-value {
        font-size: 0.75rem;
        padding: 0.25rem 0.4rem;
      }
      
      .sensor-card.accelerometer .sensor-value {
        font-size: 0.7rem;
        padding: 0.2rem 0.3rem;
      }
    }

    @media (max-width: 768px) {
      .data-list {
        padding: 1rem;
      }
      
      .sensor-grid {
        grid-template-columns: 1fr;
        grid-template-rows: repeat(4, auto);
        gap: 0.6rem;
        max-height: none;
      }
      
      .sensor-card {
        padding: 0.7rem;
        max-height: 120px;
        gap: 0.4rem;
      }
      
      .sensor-title {
        font-size: 0.8rem;
        padding-bottom: 0.2rem;
      }
      
      .sensor-value {
        font-size: 0.7rem;
        margin: 0.05rem 0;
        padding: 0.2rem 0.3rem;
      }
      
      .sensor-card.accelerometer .sensor-value {
        font-size: 0.65rem;
        padding: 0.15rem 0.25rem;
      }
      
      .alert-message {
        font-size: 0.65rem;
        padding: 0.3rem 0.4rem;
        max-height: 35px;
        -webkit-line-clamp: 2;
      }
    }

    @media (max-width: 480px) {
      .data-list h2 {
        font-size: 1.1rem;
        margin-bottom: 0.8rem;
      }
      
      .sensor-grid {
        gap: 0.5rem;
      }
      
      .sensor-card {
        padding: 0.6rem;
        gap: 0.3rem;
        max-height: 100px;
      }
      
      .sensor-title {
        font-size: 0.75rem;
      }
      
      .sensor-value {
        font-size: 0.65rem;
        padding: 0.15rem 0.25rem;
      }
      
      .sensor-card.accelerometer .sensor-value {
        font-size: 0.6rem;
        padding: 0.1rem 0.2rem;
        margin: 0.02rem 0;
      }
      
      .alert-message {
        font-size: 0.6rem;
        padding: 0.25rem 0.3rem;
        -webkit-line-clamp: 1;
        max-height: 30px;
      }
    }

    /* Animation pour les valeurs qui changent */
    .sensor-value.updated {
      animation: valueUpdate 0.3s ease-in-out;
    }

    @keyframes valueUpdate {
      0% { 
        background: rgba(59, 130, 246, 0.2);
        transform: scale(1.02);
      }
      100% { 
        background: rgba(255, 255, 255, 0.5);
        transform: scale(1);
      }
    }

    /* Effet hover pour les cartes */
    .sensor-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
      border-radius: 16px;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .sensor-card:hover::before {
      opacity: 1;
    }
  </style>
</head>
<body>
  <h1>üî¨ Nordic Thingy Dashboard - Professional Sensor Monitoring</h1>
  
  <!-- Navigation Menu -->
  <div class="navigation">
    <a href="/" class="nav-btn active">
      üè† Dashboard
    </a>
    <a href="/chart" class="nav-btn">
      üìà Charts
    </a>
    <a href="/sensors" class="nav-btn">
      üå°Ô∏è Sensors
    </a>
    <a href="/motion" class="nav-btn">
      üèÉ Motion
    </a>
    <a href="/patients" class="nav-btn">
      üë• Patients
    </a>
  </div>
  
  <div class="main-container">
    <!-- Nordic Thingy Chart -->
    <div class="chart-container">
      <h2>üìà Nordic Thingy Accelerometer</h2>
      <canvas id="accelChart"></canvas>
    </div>
    
    <!-- Mbient Chart -->
    <div class="chart-container-mbient">
      <h2>üìä Mbient Accelerometer</h2>
      <canvas id="mbientChart"></canvas>
    </div>
    
    <!-- Sensor Data Cards -->
    <div class="data-list">
      <h2>üìä Live Sensor Data</h2>
      <div class="sensor-grid" id="sensorGrid">
        <!-- Cards will be added dynamically -->
      </div>
    </div>

    <!-- Motion Indicator -->
    <div class="motion-indicator">
      <div class="motion-title">üèÉ Motion Detection</div>
      <div id="motionVisual" class="motion-visual neutral">
        <img id="motionImage" src="" alt="Motion Avatar" style="display: none;">
        <span id="motionFallback">‚ö™</span>
      </div>
      <div id="motionDescription" class="motion-description neutral">
        Initializing...
      </div>
    </div>

    <!-- Recording Controls -->
    <div class="recording-section">
      <div class="recording-left">
        <h2>üìπ Data Recording</h2>
        <div class="recording-status idle" id="recordingStatus">
          üî¥ Ready to Record
        </div>
      </div>
      
      <div class="recording-center">
        <button class="btn btn-start" id="startBtn">
          ‚ñ∂Ô∏è Start Recording
        </button>
        <button class="btn btn-stop" id="stopBtn" disabled>
          ‚èπÔ∏è Stop Recording
        </button>
        <button class="btn btn-download" id="downloadBtn" disabled>
          üíæ Download CSV
        </button>
      </div>

      <div class="recording-right" id="recordingInfo" style="display: none;">
        <div class="recording-info-item">
          <strong id="recordingDuration">0:00</strong>
          <span>Duration</span>
        </div>
        <div class="recording-info-item">
          <strong id="recordingCount">0</strong>
          <span>Data Points</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    class SensorDashboard {
        constructor(apiUrl, intervalMs = 1000) {
          this.apiUrl = apiUrl;
          this.intervalMs = intervalMs;
          this.maxPoints = 50;
          this.timer = null;
          this.statusEl = document.getElementById('status');
          this.sensorGridEl = document.getElementById('sensorGrid');
          this.motionVisualEl = document.getElementById('motionVisual');
          this.motionDescriptionEl = document.getElementById('motionDescription');
          this.motionImageEl = document.getElementById('motionImage');
          this.motionFallbackEl = document.getElementById('motionFallback');
          this.errorCount = 0;
          this.successCount = 0;
          
          // Recording variables
          this.isRecording = false;
          this.currentSessionId = null;
          this.recordingStartTime = null;
          this.recordingTimer = null;
          this.recordingCount = 0;
          this.downloadUrl = null;
          
          // Load available assets
          this.availableAssets = new Set();
          this.loadAvailableAssets();
          
          this.initCharts();
          this.initSensorCards();
          this.initRecordingControls();
        }

        async loadAvailableAssets() {
          try {
            const response = await fetch('/api/assets');
            if (response.ok) {
              const assets = await response.json();
              assets.forEach(asset => {
                this.availableAssets.add(asset.name);
              });
              console.log('‚úÖ Assets loaded:', Array.from(this.availableAssets));
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not load assets:', error);
          }
        }

        initRecordingControls() {
          const startBtn = document.getElementById('startBtn');
          const stopBtn = document.getElementById('stopBtn');
          const downloadBtn = document.getElementById('downloadBtn');
          const recordingInfo = document.getElementById('recordingInfo');
          const recordingStatus = document.getElementById('recordingStatus');

          startBtn.addEventListener('click', async () => {
            try {
              const response = await fetch('/api/sessions/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              });

              if (response.ok) {
                const data = await response.json();
                this.currentSessionId = data.sessionId;
                this.isRecording = true;
                this.recordingStartTime = Date.now();
                this.recordingCount = 0;

                startBtn.disabled = true;
                stopBtn.disabled = false;
                downloadBtn.disabled = true;
                recordingInfo.style.display = 'flex';
                recordingStatus.textContent = 'üî¥ Recording Active';
                recordingStatus.className = 'recording-status recording';

                this.recordingTimer = setInterval(() => {
                  this.updateRecordingInfo();
                }, 1000);
              }
            } catch (error) {
              console.error('‚ùå Start recording error:', error);
            }
          });

          stopBtn.addEventListener('click', async () => {
            try {
              if (this.currentSessionId) {
                const response = await fetch(`/api/sessions/${this.currentSessionId}/stop`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' }
                });

                if (response.ok) {
                  const data = await response.json();
                  this.downloadUrl = data.downloadUrl;
                  this.isRecording = false;

                  startBtn.disabled = false;
                  stopBtn.disabled = true;
                  downloadBtn.disabled = false;
                  recordingStatus.textContent = '‚úÖ Recording Complete';
                  recordingStatus.className = 'recording-status complete';

                  if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                  }
                }
              }
            } catch (error) {
              console.error('‚ùå Stop recording error:', error);
            }
          });

          downloadBtn.addEventListener('click', () => {
            if (this.downloadUrl) {
              window.open(this.downloadUrl, '_blank');
            }
          });
        }

        updateRecordingInfo() {
          if (!this.recordingStartTime) return;

          const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          
          document.getElementById('recordingDuration').textContent = 
            `${minutes}:${seconds.toString().padStart(2, '0')}`;
          document.getElementById('recordingCount').textContent = this.recordingCount;
        }

        async recordDataPoint() {
          if (!this.isRecording || !this.currentSessionId) return;

          try {
            const response = await fetch(`/api/sessions/${this.currentSessionId}/record`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' }
            });

            if (response.ok) {
              this.recordingCount++;
            }
          } catch (error) {
            // Silent error handling
          }
        }

        initCharts() {
          // Nordic Thingy Chart with professional styling
          const nordicCtx = document.getElementById('accelChart').getContext('2d');
          this.nordicChart = new Chart(nordicCtx, {
            type: 'line',
            data: {
              labels: Array(this.maxPoints).fill(''),
              datasets: [
                {
                  label: 'X-axis',
                  data: Array(this.maxPoints).fill(0),
                  borderColor: '#ef4444',
                  backgroundColor: 'rgba(239, 68, 68, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  fill: false,
                  pointRadius: 0,
                  pointHoverRadius: 4
                },
                {
                  label: 'Y-axis',
                  data: Array(this.maxPoints).fill(0),
                  borderColor: '#3b82f6',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  fill: false,
                  pointRadius: 0,
                  pointHoverRadius: 4
                },
                {
                  label: 'Z-axis',
                  data: Array(this.maxPoints).fill(0),
                  borderColor: '#10b981',
                  backgroundColor: 'rgba(16, 185, 129, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  fill: false,
                  pointRadius: 0,
                  pointHoverRadius: 4
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false,
              interaction: {
                intersect: false,
                mode: 'index'
              },
              scales: {
                x: { 
                  display: false,
                  grid: { display: false }
                },
                y: {
                  title: { 
                    display: true, 
                    text: 'Acceleration (g)', 
                    font: { size: 12, family: 'Inter', weight: '500' },
                    color: '#374151'
                  },
                  suggestedMin: -2,
                  suggestedMax: 2,
                  grid: { 
                    color: 'rgba(203, 213, 225, 0.3)',
                    borderDash: [5, 5]
                  },
                  ticks: { 
                    font: { size: 11, family: 'Inter' },
                    color: '#64748b'
                  }
                }
              },
              plugins: {
                legend: { 
                  position: 'top',
                  labels: { 
                    boxWidth: 12, 
                    padding: 20, 
                    font: { size: 12, family: 'Inter', weight: '500' },
                    color: '#374151'
                  }
                },
                title: { 
                  display: false
                }
              }
            }
          });

          // Mbient Chart with professional styling
          const mbientCtx = document.getElementById('mbientChart').getContext('2d');
          this.mbientChart = new Chart(mbientCtx, {
            type: 'line',
            data: {
              labels: Array(this.maxPoints).fill(''),
              datasets: [
                {
                  label: 'X-axis',
                  data: Array(this.maxPoints).fill(0),
                  borderColor: '#f59e0b',
                  backgroundColor: 'rgba(245, 158, 11, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  fill: false,
                  pointRadius: 0,
                  pointHoverRadius: 4
                },
                {
                  label: 'Y-axis',
                  data: Array(this.maxPoints).fill(0),
                  borderColor: '#8b5cf6',
                  backgroundColor: 'rgba(139, 92, 246, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  fill: false,
                  pointRadius: 0,
                  pointHoverRadius: 4
                },
                {
                  label: 'Z-axis',
                  data: Array(this.maxPoints).fill(0),
                  borderColor: '#06b6d4',
                  backgroundColor: 'rgba(6, 182, 212, 0.1)',
                  borderWidth: 2.5,
                  tension: 0.4,
                  fill: false,
                  pointRadius: 0,
                  pointHoverRadius: 4
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: false,
              interaction: {
                intersect: false,
                mode: 'index'
              },
              scales: {
                x: { 
                  display: false,
                  grid: { display: false }
                },
                y: {
                  title: { 
                    display: true, 
                    text: 'Acceleration (g)', 
                    font: { size: 12, family: 'Inter', weight: '500' },
                    color: '#374151'
                  },
                  suggestedMin: -2,
                  suggestedMax: 2,
                  grid: { 
                    color: 'rgba(203, 213, 225, 0.3)',
                    borderDash: [5, 5]
                  },
                  ticks: { 
                    font: { size: 11, family: 'Inter' },
                    color: '#64748b'
                  }
                }
              },
              plugins: {
                legend: { 
                  position: 'top',
                  labels: { 
                    boxWidth: 12, 
                    padding: 20, 
                    font: { size: 12, family: 'Inter', weight: '500' },
                    color: '#374151'
                  }
                },
                title: { 
                  display: false
                }
              }
            }
          });
        }

        initSensorCards() {
          this.sensorGridEl.innerHTML = `
            <div class="sensor-card accelerometer">
              <div class="sensor-title">üèÉ Accelerometer</div>
              <div class="sensor-value" id="accel-x">X: --</div>
              <div class="sensor-value" id="accel-y">Y: --</div>
              <div class="sensor-value" id="accel-z">Z: --</div>
            </div>
            
            <div class="sensor-card temperature">
              <div class="sensor-title">üå°Ô∏è Temperature</div>
              <div class="sensor-value" id="temperature">-- ¬∞C</div>
              <div class="alert-message" id="temp-alert"></div>
            </div>
            
            <div class="sensor-card humidity">
              <div class="sensor-title">üíß Humidity</div>
              <div class="sensor-value" id="humidity">-- %</div>
              <div class="alert-message" id="humidity-alert"></div>
            </div>
            
            <div class="sensor-card air-quality">
              <div class="sensor-title">üå¨Ô∏è Air Quality</div>
              <div class="sensor-value" id="co2">CO‚ÇÇ: --</div>
              <div class="sensor-value" id="tvoc">TVOC: --</div>
              <div class="alert-message" id="air-alert"></div>
            </div>
          `;
        }

        async fetchData() {
          try {
            const response = await fetch('/api/sensor-data-combined', {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            let data = await response.json();
            
            if (typeof data === 'string') {
              data = JSON.parse(data);
            }
            
            if (!data || typeof data !== 'object') {
              throw new Error('Invalid data format received');
            }
            
            this.successCount++;
            this.errorCount = 0;
            
            return data;
            
          } catch (error) {
            this.errorCount++;
            console.error('Fetch error:', error);
            return null;
          }
        }

        updateCharts(data) {
          if (!data) return;
          
          // Update Nordic chart
          if (data.nordic && data.nordic.accelerometer) {
            const { x, y, z } = data.nordic.accelerometer;
            
            this.nordicChart.data.datasets[0].data.push(x);
            this.nordicChart.data.datasets[1].data.push(y);
            this.nordicChart.data.datasets[2].data.push(z);
            
            this.nordicChart.data.datasets.forEach(dataset => {
              if (dataset.data.length > this.maxPoints) {
                dataset.data.shift();
              }
            });
            
            this.nordicChart.update('none');
          }
          
          // Update Mbient chart
          if (data.mbient && data.mbient.accelerometer) {
            const { x, y, z } = data.mbient.accelerometer;
            
            this.mbientChart.data.datasets[0].data.push(x);
            this.mbientChart.data.datasets[1].data.push(y);
            this.mbientChart.data.datasets[2].data.push(z);
            
            this.mbientChart.data.datasets.forEach(dataset => {
              if (dataset.data.length > this.maxPoints) {
                dataset.data.shift();
              }
            });
            
            this.mbientChart.update('none');
          }
        }

        updateSensorCards(data) {
          if (!data) return;
          
          // Use Nordic data for sensor cards
          const nordicData = data.nordic || data;
          
          if (nordicData.accelerometer) {
            // Ajouter des animations aux changements de valeurs
            this.updateValueWithAnimation('accel-x', `X: ${nordicData.accelerometer.x.toFixed(2)}`);
            this.updateValueWithAnimation('accel-y', `Y: ${nordicData.accelerometer.y.toFixed(2)}`);
            this.updateValueWithAnimation('accel-z', `Z: ${nordicData.accelerometer.z.toFixed(2)}`);
          }

          if (nordicData.temperature !== undefined) {
            this.updateValueWithAnimation('temperature', `${nordicData.temperature.toFixed(1)} ¬∞C`);
            const tempAlert = document.getElementById('temp-alert');
            if (tempAlert) {
              let alertText = nordicData.temperaturealert || '';
              // Limiter la longueur des alertes
              if (alertText.length > 35) {
                alertText = alertText.substring(0, 32) + '...';
              }
              tempAlert.textContent = alertText;
              tempAlert.className = this.getAlertClass(nordicData.temperaturealert);
              tempAlert.style.display = alertText ? 'block' : 'none';
            }
          }

          if (nordicData.humidity !== undefined) {
            this.updateValueWithAnimation('humidity', `${nordicData.humidity} %`);
            const humAlert = document.getElementById('humidity-alert');
            if (humAlert) {
              let alertText = nordicData.humidityalert || '';
              // Limiter la longueur des alertes
              if (alertText.length > 35) {
                alertText = alertText.substring(0, 32) + '...';
              }
              humAlert.textContent = alertText;
              humAlert.className = this.getAlertClass(nordicData.humidityalert);
              humAlert.style.display = alertText ? 'block' : 'none';
            }
          }

          if (nordicData.air_quality) {
            this.updateValueWithAnimation('co2', `CO‚ÇÇ: ${nordicData.air_quality.CO2}`);
            this.updateValueWithAnimation('tvoc', `TVOC: ${nordicData.air_quality.TVOC}`);
            const airAlert = document.getElementById('air-alert');
            if (airAlert) {
              let alertText = nordicData.air_qualityalert || '';
              
              // Si pas d'alerte de l'API, g√©n√©rer une bas√©e sur les valeurs
              if (!alertText && nordicData.air_quality.CO2 && nordicData.air_quality.TVOC) {
                const co2Value = parseInt(nordicData.air_quality.CO2) || 0;
                const tvocValue = parseInt(nordicData.air_quality.TVOC) || 0;
                
                if (co2Value > 1000 || tvocValue > 1000) {
                  alertText = 'Poor air quality detected';
                } else if (co2Value > 800 || tvocValue > 500) {
                  alertText = 'Moderate air quality';
                } else if (co2Value > 0 || tvocValue > 0) {
                  alertText = 'Good air quality';
                }
              }
              
              // Limiter la longueur des alertes
              if (alertText.length > 35) {
                alertText = alertText.substring(0, 32) + '...';
              }
              
              airAlert.textContent = alertText;
              airAlert.className = this.getAlertClass(alertText);
              airAlert.style.display = alertText ? 'block' : 'none';
            }
          }
          
          // Continue to update motion indicator (this is separate from the sensor cards)
          this.updateMotionIndicator(nordicData.motionalert);
        }

        // Nouvelle m√©thode pour animer les changements de valeurs
        updateValueWithAnimation(elementId, newValue) {
          const element = document.getElementById(elementId);
          if (element && element.textContent !== newValue) {
            element.textContent = newValue;
            element.classList.add('updated');
            setTimeout(() => {
              element.classList.remove('updated');
            }, 300);
          }
        }

        async fetchData() {
          try {
            const response = await fetch('/api/sensor-data-combined', {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            let data = await response.json();
            
            if (typeof data === 'string') {
              data = JSON.parse(data);
            }
            
            if (!data || typeof data !== 'object') {
              throw new Error('Invalid data format received');
            }
            
            this.successCount++;
            this.errorCount = 0;
            
            return data;
            
          } catch (error) {
            this.errorCount++;
            console.error('Fetch error:', error);
            return null;
          }
        }

        updateCharts(data) {
          if (!data) return;
          
          // Update Nordic chart
          if (data.nordic && data.nordic.accelerometer) {
            const { x, y, z } = data.nordic.accelerometer;
            
            this.nordicChart.data.datasets[0].data.push(x);
            this.nordicChart.data.datasets[1].data.push(y);
            this.nordicChart.data.datasets[2].data.push(z);
            
            this.nordicChart.data.datasets.forEach(dataset => {
              if (dataset.data.length > this.maxPoints) {
                dataset.data.shift();
              }
            });
            
            this.nordicChart.update('none');
          }
          
          // Update Mbient chart
          if (data.mbient && data.mbient.accelerometer) {
            const { x, y, z } = data.mbient.accelerometer;
            
            this.mbientChart.data.datasets[0].data.push(x);
            this.mbientChart.data.datasets[1].data.push(y);
            this.mbientChart.data.datasets[2].data.push(z);
            
            this.mbientChart.data.datasets.forEach(dataset => {
              if (dataset.data.length > this.maxPoints) {
                dataset.data.shift();
              }
            });
            
            this.mbientChart.update('none');
          }
        }

        updateSensorCards(data) {
          if (!data) return;
          
          // Use Nordic data for sensor cards
          const nordicData = data.nordic || data;
          
          if (nordicData.accelerometer) {
            // Ajouter des animations aux changements de valeurs
            this.updateValueWithAnimation('accel-x', `X: ${nordicData.accelerometer.x.toFixed(2)}`);
            this.updateValueWithAnimation('accel-y', `Y: ${nordicData.accelerometer.y.toFixed(2)}`);
            this.updateValueWithAnimation('accel-z', `Z: ${nordicData.accelerometer.z.toFixed(2)}`);
          }

          if (nordicData.temperature !== undefined) {
            this.updateValueWithAnimation('temperature', `${nordicData.temperature.toFixed(1)} ¬∞C`);
            const tempAlert = document.getElementById('temp-alert');
            if (tempAlert) {
              let alertText = nordicData.temperaturealert || '';
              // Limiter la longueur des alertes
              if (alertText.length > 35) {
                alertText = alertText.substring(0, 32) + '...';
              }
              tempAlert.textContent = alertText;
              tempAlert.className = this.getAlertClass(nordicData.temperaturealert);
              tempAlert.style.display = alertText ? 'block' : 'none';
            }
          }

          if (nordicData.humidity !== undefined) {
            this.updateValueWithAnimation('humidity', `${nordicData.humidity} %`);
            const humAlert = document.getElementById('humidity-alert');
            if (humAlert) {
              let alertText = nordicData.humidityalert || '';
              // Limiter la longueur des alertes
              if (alertText.length > 35) {
                alertText = alertText.substring(0, 32) + '...';
              }
              humAlert.textContent = alertText;
              humAlert.className = this.getAlertClass(nordicData.humidityalert);
              humAlert.style.display = alertText ? 'block' : 'none';
            }
          }

          if (nordicData.air_quality) {
            this.updateValueWithAnimation('co2', `CO‚ÇÇ: ${nordicData.air_quality.CO2}`);
            this.updateValueWithAnimation('tvoc', `TVOC: ${nordicData.air_quality.TVOC}`);
            const airAlert = document.getElementById('air-alert');
            if (airAlert) {
              let alertText = nordicData.air_qualityalert || '';
              
              // Si pas d'alerte de l'API, g√©n√©rer une bas√©e sur les valeurs
              if (!alertText && nordicData.air_quality.CO2 && nordicData.air_quality.TVOC) {
                const co2Value = parseInt(nordicData.air_quality.CO2) || 0;
                const tvocValue = parseInt(nordicData.air_quality.TVOC) || 0;
                
                if (co2Value > 1000 || tvocValue > 1000) {
                  alertText = 'Poor air quality detected';
                } else if (co2Value > 800 || tvocValue > 500) {
                  alertText = 'Moderate air quality';
                } else if (co2Value > 0 || tvocValue > 0) {
                  alertText = 'Good air quality';
                }
              }
              
              // Limiter la longueur des alertes
              if (alertText.length > 35) {
                alertText = alertText.substring(0, 32) + '...';
              }
              
              airAlert.textContent = alertText;
              airAlert.className = this.getAlertClass(alertText);
              airAlert.style.display = alertText ? 'block' : 'none';
            }
          }
          
          // Continue to update motion indicator (this is separate from the sensor cards)
          this.updateMotionIndicator(nordicData.motionalert);
        }

        // Nouvelle m√©thode pour animer les changements de valeurs
        updateValueWithAnimation(elementId, newValue) {
          const element = document.getElementById(elementId);
          if (element && element.textContent !== newValue) {
            element.textContent = newValue;
            element.classList.add('updated');
            setTimeout(() => {
              element.classList.remove('updated');
            }, 300);
          }
        }

        getAlertClass(alertText) {
          if (!alertText) return 'alert-message';
          
          const text = alertText.toLowerCase();
          if (text.includes('no alert') || text.includes('good') || text.includes('excellent')) {
            return 'alert-message good';
          } else if (text.includes('poor') || text.includes('bad') || text.includes('high') || text.includes('danger')) {
            return 'alert-message danger';
          } else if (text.includes('moderate') || text.includes('medium') || text.includes('consider')) {
            return 'alert-message warning';
          } else {
            return 'alert-message warning';
          }
        }

        updateMotionIndicator(motionAlert) {
          if (!motionAlert) return;

          // Clear existing classes
          this.motionVisualEl.className = 'motion-visual';
          this.motionDescriptionEl.className = 'motion-description';

          let fallbackIcon = '‚ö™';
          let description = motionAlert;
          let imageUrl = null;

          // Extract image name (remove " - BAD MOVEMENT" suffix if present)
          const imageName = motionAlert.replace(/ - BAD MOVEMENT$/i, '');

          // Look for corresponding image in assets using the clean image name
          if (this.availableAssets.has(imageName)) {
            imageUrl = `/assets/${imageName}.png`;
            description = motionAlert; // Keep the full alert with BAD MOVEMENT
          } else {
            // Just use the raw alert
            fallbackIcon = '‚ùì';
            description = motionAlert;
          }

          // Apply changes
          this.motionDescriptionEl.textContent = description;

          if (imageUrl) {
            this.motionImageEl.src = imageUrl;
            this.motionImageEl.style.display = 'block';
            this.motionFallbackEl.style.display = 'none';

            // Handle image loading error
            this.motionImageEl.onerror = () => {
              console.warn('‚ùå Cannot load image:', imageUrl);
              this.motionImageEl.style.display = 'none';
              this.motionFallbackEl.style.display = 'flex';
              this.motionFallbackEl.textContent = fallbackIcon;
              this.motionVisualEl.classList.add('no-image');
            };
          } else {
            // Use fallback
            this.motionImageEl.style.display = 'none';
            this.motionFallbackEl.style.display = 'flex';
            this.motionFallbackEl.textContent = fallbackIcon;
            this.motionVisualEl.classList.add('no-image');
          }
        }

        async refresh() {
          const data = await this.fetchData();
          if (data) {
            this.updateCharts(data);
            this.updateSensorCards(data);
            
            if (this.isRecording) {
              await this.recordDataPoint();
            }
          }
        }

        start() {
          this.refresh();
          this.timer = setInterval(() => this.refresh(), this.intervalMs);
        }

        stop() {
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
          
          if (this.recordingTimer) {
            clearInterval(this.recordingTimer);
          }
        }
    }

    // Automatic startup
    document.addEventListener('DOMContentLoaded', () => {
      window.dashboard = new SensorDashboard('/api/sensor-data-combined', 1000);
      window.dashboard.start();
    });

    window.addEventListener('beforeunload', () => {
      if (window.dashboard) {
        window.dashboard.stop();
      }
    });
</script>
</body>
</html>